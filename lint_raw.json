[{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\electron.vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\scripts\\dev.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\scripts\\download-ffmpeg.mjs","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":19,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":19,"endColumn":18},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":22,"column":26,"nodeType":"ArrowFunctionExpression","messageId":"missingReturnType","endLine":22,"endColumn":28},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":59,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":59,"endColumn":20}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Auto-download FFmpeg binary with QSV support for Windows.\n * Run: node scripts/download-ffmpeg.mjs\n */\nimport { createWriteStream, existsSync, mkdirSync } from 'fs'\nimport { join, dirname } from 'path'\nimport { fileURLToPath } from 'url'\nimport { execSync } from 'child_process'\nimport https from 'https'\n\nconst __dirname = dirname(fileURLToPath(import.meta.url))\nconst RESOURCES_DIR = join(__dirname, '..', 'resources', 'ffmpeg')\nconst FFMPEG_PATH = join(RESOURCES_DIR, 'ffmpeg.exe')\nconst FFPROBE_PATH = join(RESOURCES_DIR, 'ffprobe.exe')\n\n// Using gyan.dev full build which includes QSV support\nconst FFMPEG_URL = 'https://www.gyan.dev/ffmpeg/builds/ffmpeg-release-essentials.zip'\n\nfunction download(url, dest) {\n  return new Promise((resolve, reject) => {\n    console.log(`Downloading FFmpeg from:\\n  ${url}`)\n    const follow = (url) => {\n      https\n        .get(url, (res) => {\n          if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n            follow(res.headers.location)\n            return\n          }\n          if (res.statusCode !== 200) {\n            reject(new Error(`HTTP ${res.statusCode}`))\n            return\n          }\n          const total = parseInt(res.headers['content-length'] || '0', 10)\n          let downloaded = 0\n          const file = createWriteStream(dest)\n          res.on('data', (chunk) => {\n            downloaded += chunk.length\n            if (total) {\n              const pct = ((downloaded / total) * 100).toFixed(1)\n              process.stdout.write(\n                `\\r  Progress: ${pct}% (${(downloaded / 1048576).toFixed(1)} MB)`\n              )\n            }\n          })\n          res.pipe(file)\n          file.on('finish', () => {\n            file.close()\n            console.log('\\n  Download complete.')\n            resolve()\n          })\n          file.on('error', reject)\n        })\n        .on('error', reject)\n    }\n    follow(url)\n  })\n}\n\nasync function main() {\n  if (existsSync(FFMPEG_PATH) && existsSync(FFPROBE_PATH)) {\n    console.log('FFmpeg already exists at:', FFMPEG_PATH)\n    console.log('FFprobe already exists at:', FFPROBE_PATH)\n    return\n  }\n\n  mkdirSync(RESOURCES_DIR, { recursive: true })\n\n  const zipPath = join(RESOURCES_DIR, 'ffmpeg.zip')\n  await download(FFMPEG_URL, zipPath)\n\n  console.log('Extracting ffmpeg.exe and ffprobe.exe...')\n  const psCmd = `\n    $zip = [System.IO.Compression.ZipFile]::OpenRead('${zipPath.replace(/\\\\/g, '\\\\\\\\')}')\n    $ffmpegEntry = $zip.Entries | Where-Object { $_.Name -eq 'ffmpeg.exe' } | Select-Object -First 1\n    $ffprobeEntry = $zip.Entries | Where-Object { $_.Name -eq 'ffprobe.exe' } | Select-Object -First 1\n    if ($ffmpegEntry) {\n      [System.IO.Compression.ZipFileExtensions]::ExtractToFile($ffmpegEntry, '${FFMPEG_PATH.replace(/\\\\/g, '\\\\\\\\')}', $true)\n      Write-Host \"Extracted ffmpeg.exe\"\n    } else {\n      Write-Host \"ffmpeg.exe not found in archive\"\n    }\n    if ($ffprobeEntry) {\n      [System.IO.Compression.ZipFileExtensions]::ExtractToFile($ffprobeEntry, '${FFPROBE_PATH.replace(/\\\\/g, '\\\\\\\\')}', $true)\n      Write-Host \"Extracted ffprobe.exe\"\n    } else {\n      Write-Host \"ffprobe.exe not found in archive\"\n    }\n    $zip.Dispose()\n    Remove-Item '${zipPath.replace(/\\\\/g, '\\\\\\\\')}' -Force\n  `.trim()\n\n  execSync(\n    `powershell -Command \"Add-Type -AssemblyName System.IO.Compression.FileSystem; ${psCmd}\"`,\n    {\n      stdio: 'inherit'\n    }\n  )\n\n  if (existsSync(FFMPEG_PATH) && existsSync(FFPROBE_PATH)) {\n    console.log('FFmpeg ready at:', FFMPEG_PATH)\n    console.log('FFprobe ready at:', FFPROBE_PATH)\n  } else {\n    console.error('ERROR: Failed to extract ffmpeg/ffprobe binaries')\n    process.exit(1)\n  }\n}\n\nmain().catch((err) => {\n  console.error('Failed to download FFmpeg:', err.message)\n  process.exit(1)\n})\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\scripts\\download-ffmpeg.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'finished' is defined but never used.","line":5,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":5,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"finished"},"fix":{"range":[159,202],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'Readable' is defined but never used.","line":6,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":18,"suggestions":[{"messageId":"removeUnusedImportDeclaration","data":{"varName":"Readable"},"fix":{"range":[202,236],"text":""},"desc":"Remove unused import declaration."}]},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":14,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":14,"endColumn":28},{"ruleId":"@typescript-eslint/no-require-imports","severity":2,"message":"A `require()` style import is forbidden.","line":78,"column":16,"nodeType":"CallExpression","messageId":"noRequireImports","endLine":78,"endColumn":29}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { createWriteStream, mkdirSync, existsSync } from 'fs'\nimport { join } from 'path'\nimport { get } from 'https'\nimport { execSync } from 'child_process'\nimport { finished } from 'stream/promises'\nimport { Readable } from 'stream'\n\n// Simplified download script for FFmpeg (Windows)\nconst FFMPEG_URL =\n  'https://github.com/BtbN/FFmpeg-Builds/releases/download/latest/ffmpeg-master-latest-win64-gpl.zip'\nconst RESOURCES_DIR = join(process.cwd(), 'resources', 'ffmpeg')\nconst ZIP_PATH = join(process.cwd(), 'ffmpeg.zip')\n\nasync function downloadFile(url: string, dest: string) {\n  return new Promise((resolve, reject) => {\n    get(url, (res) => {\n      if (res.statusCode === 302 || res.statusCode === 301) {\n        downloadFile(res.headers.location!, dest).then(resolve).catch(reject)\n        return\n      }\n      const file = createWriteStream(dest)\n      res.pipe(file)\n      file.on('finish', () => {\n        file.close()\n        resolve(true)\n      })\n    }).on('error', reject)\n  })\n}\n\n;(async () => {\n  console.log('Downloading FFmpeg...')\n  if (!existsSync(RESOURCES_DIR)) {\n    mkdirSync(RESOURCES_DIR, { recursive: true })\n  }\n\n  await downloadFile(FFMPEG_URL, ZIP_PATH)\n  console.log('Download complete. Extracting...')\n\n  // Use powershell to extract\n  try {\n    // Clean previous extraction\n    // Extract specific file if possible, or extract all and move\n    execSync(\n      `powershell -command \"Expand-Archive -Path '${ZIP_PATH}' -DestinationPath '${process.cwd()}' -Force\"`\n    )\n\n    // Move ffmpeg.exe to resources/ffmpeg/\n    // The zip has a folder structure like ffmpeg-master-latest-win64-gpl/bin/ffmpeg.exe\n    const extractedRoot = join(process.cwd(), 'ffmpeg-master-latest-win64-gpl')\n    const binPath = join(extractedRoot, 'bin', 'ffmpeg.exe')\n    const ffprobePath = join(extractedRoot, 'bin', 'ffprobe.exe')\n\n    const destFfmpeg = join(RESOURCES_DIR, 'ffmpeg.exe')\n    // const destFfprobe = join(RESOURCES_DIR, 'ffprobe.exe'); // probe uses ffmpeg command too? No, ffprobe is separate.\n    // Wait, my code uses `spawn(ffmpegPath, ...)`?\n    // In `ffmpeg.ts`: `ipcMain.handle('ffmpeg:probe', ...)` uses `ffmpegPath`?\n    // No, let's check `ffmpeg.ts`.\n\n    // Check ffmpeg.ts:\n    // const ffprobe = spawn(ffmpegPath, ... -v error ...)\n    // Wait, `ffmpeg -i file` can probe, but `ffprobe` is a separate binary usually.\n    // My code spawns `ffmpegPath` with arguments.\n    // Line 33: `const ffprobe = spawn(ffmpegPath, ...)`\n    // Is it invoking `ffmpeg` or `ffprobe`?\n    // Arguments: `['-v', 'error', '-select_streams', 'v:0', '-show_entries', ...]`\n    // These are `ffprobe` arguments! `ffmpeg` doesn't support `-show_entries` directly in the same way without `-f ffmetadata` or acts differently.\n    // Actually `ffprobe` arguments are specific.\n    // If `ffmpegPath` points to `ffmpeg.exe`, running `ffmpeg.exe -show_entries` might fail or work depending on version/build, but usually `ffprobe.exe` is needed.\n    // Standard `ffmpeg` binary does NOT include `ffprobe` functionality in `ffmpeg` command.\n    // I MUST have `ffprobe.exe` and point to it, OR use `ffmpeg -i input` and parse stderr.\n    // My code uses `spawn(ffmpegPath, ...)` where `ffmpegPath` is `ffmpeg.exe`.\n\n    // FIX: I need `ffprobe.exe` as well and `ffmpeg.ts` should likely use it.\n    // Or I should parse `ffmpeg -i` output which is less reliable json.\n    // Correct approach: Download both.\n\n    const fs = require('fs')\n    if (fs.existsSync(binPath)) {\n      fs.renameSync(binPath, destFfmpeg)\n      console.log(`Moved ffmpeg.exe to ${destFfmpeg}`)\n    }\n\n    // Also move ffprobe if present\n    const destProbe = join(RESOURCES_DIR, 'ffprobe.exe')\n    if (fs.existsSync(ffprobePath)) {\n      fs.renameSync(ffprobePath, destProbe)\n      console.log(`Moved ffprobe.exe to ${destProbe}`)\n    }\n\n    // Cleanup\n    fs.rmSync(extractedRoot, { recursive: true, force: true })\n    fs.unlinkSync(ZIP_PATH)\n    console.log('Done!')\n  } catch (e) {\n    console.error('Extraction failed:', e)\n  }\n})()\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\main\\gemini.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\main\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\main\\store.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":69,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1473,1476],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1473,1476],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":71,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":71,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1528,1531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1528,1531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":101,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2424,2427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2424,2427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"Ôªøimport { ipcMain } from 'electron'\n\ninterface StoreSchema {\n  geminiApiKey: string\n  captionSettings: {\n    arabicFont: string\n    bengaliFont: string\n    arabicSize: number\n    bengaliSize: number\n    arabicColor: string\n    bengaliColor: string\n    gap: number\n    strokeColor: string\n    strokeWidth: number\n    shadowColor: string\n    shadowBlur: number\n    positionY: number\n    animation?: string\n  }\n  renderSettings: {\n    encoder: 'av1_qsv' | 'hevc_qsv' | 'libsvtav1' | 'libx265'\n    bitrate: string\n    enableSlowMo: boolean\n    slowMoFps: number\n    videoFilter: 'none' | 'cinematic' | 'bw' | 'warm' | 'cool'\n  }\n  watermark: {\n    path: string\n    x: number\n    y: number\n    width: number\n    height: number\n    opacity: number\n  } | null\n  isRendering: boolean\n  lastProjectDir: string\n}\n\nconst DEFAULTS: StoreSchema = {\n  geminiApiKey: '',\n  captionSettings: {\n    arabicFont: 'Amiri',\n    bengaliFont: 'Noto Sans Bengali',\n    arabicSize: 48,\n    bengaliSize: 36,\n    arabicColor: '#ffffff',\n    bengaliColor: '#f0e68c',\n    gap: 16,\n    strokeColor: '#000000',\n    strokeWidth: 2,\n    shadowColor: 'rgba(0,0,0,0.8)',\n    shadowBlur: 8,\n    positionY: 75,\n    animation: 'none'\n  },\n  renderSettings: {\n    encoder: 'av1_qsv',\n    bitrate: '8M',\n    enableSlowMo: false,\n    slowMoFps: 60,\n    videoFilter: 'none'\n  },\n  watermark: null,\n  isRendering: false,\n  lastProjectDir: ''\n}\n\n// electron-store v8 is ESM-only ‚Äî use dynamic import\nlet storeInstance: any = null\n\nasync function getStoreInstance(): Promise<any> {\n  if (storeInstance) return storeInstance\n  const { default: Store } = await import('electron-store')\n  storeInstance = new Store({\n    name: 'quran-editor-settings',\n    defaults: DEFAULTS\n  })\n  return storeInstance\n}\n\nexport function registerStoreHandlers(): void {\n  ipcMain.removeHandler('store:get')\n  ipcMain.handle('store:get', async (_event, key: string): Promise<unknown> => {\n    const store = await getStoreInstance()\n    return store.get(key)\n  })\n\n  ipcMain.removeHandler('store:set')\n  ipcMain.handle('store:set', async (_event, key: string, value: unknown): Promise<void> => {\n    const store = await getStoreInstance()\n    store.set(key, value)\n  })\n\n  ipcMain.removeHandler('store:getAll')\n  ipcMain.handle('store:getAll', async (): Promise<unknown> => {\n    const store = await getStoreInstance()\n    return store.store\n  })\n}\n\nexport async function getStore(): Promise<any> {\n  return getStoreInstance()\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\preload\\index.d.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":15,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[469,472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[469,472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { ElectronAPI } from '@electron-toolkit/preload'\n\ninterface StoreAPI {\n  get: (key: string) => Promise<unknown>\n  set: (key: string, value: unknown) => Promise<void>\n  getAll: () => Promise<Record<string, unknown>>\n}\n\ninterface DialogAPI {\n  openFile: (filters: Array<{ name: string; extensions: string[] }>) => Promise<string | null>\n  saveFile: (defaultName: string) => Promise<string | null>\n}\n\ninterface GeminiAPI {\n  analyze: (audioPath: string) => Promise<any>\n  testConnection: () => Promise<{ success: boolean; message: string }>\n  onProgress: (callback: (data: { status: string; error?: boolean }) => void) => () => void\n}\n\ninterface FFmpegAPI {\n  getPath: () => Promise<{ path: string; exists: boolean }>\n  render: (options: unknown) => Promise<{ success: boolean; message: string }>\n  cancel: () => Promise<boolean>\n  probe: (filePath: string) => Promise<{ duration: number; width: number; height: number }>\n  extractAudio: (videoPath: string) => Promise<string>\n  onProgress: (callback: (data: { currentTime: number; line: string }) => void) => () => void\n  onDiagnostic: (\n    callback: (data: { runLabel: string; line: string; at: number }) => void\n  ) => () => void\n}\n\ninterface CaptionSegment {\n  start: number\n  end: number\n  arabic: string\n  bengali: string\n  arabicLines: string[]\n  bengaliLines: string[]\n}\n\ninterface CaptionsAPI {\n  saveImages: (\n    images: Array<{ pngDataUrl: string; start: number; end: number }>\n  ) => Promise<Array<{ path: string; start: number; end: number }>>\n}\n\ninterface FilesAPI {\n  getPath: (file: File) => string\n  write: (path: string, buffer: ArrayBuffer) => Promise<{ success: boolean; error?: string }>\n}\n\ninterface CustomAPI {\n  store: StoreAPI\n  dialog: DialogAPI\n  gemini: GeminiAPI\n  captions: CaptionsAPI\n  files: FilesAPI\n}\n\ndeclare global {\n  interface Window {\n    electron: ElectronAPI\n    api: CustomAPI\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\preload\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\CaptionControls.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":3,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":3,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5231,5234],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5231,5234],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEditorStore } from '../stores/editorStore'\n\nexport function CaptionControls() {\n  const style = useEditorStore((s) => s.captionStyle)\n  const setCaptionStyle = useEditorStore((s) => s.setCaptionStyle)\n\n  return (\n    <div className=\"panel\">\n      <div className=\"panel__section\">\n        <span className=\"panel__label\">Arabic Font</span>\n        <select\n          className=\"form-select\"\n          value={style.arabicFont}\n          onChange={(e) => setCaptionStyle({ arabicFont: e.target.value })}\n        >\n          <option value=\"Amiri\">Amiri</option>\n          <option value=\"Scheherazade New\">Scheherazade New</option>\n          <option value=\"Noto Naskh Arabic\">Noto Naskh Arabic</option>\n          <option value=\"Lateef\">Lateef</option>\n          <option value=\"Traditional Arabic\">Traditional Arabic</option>\n          <option value=\"Sakkal Majalla\">Sakkal Majalla</option>\n          <option value=\"Arabic Typesetting\">Arabic Typesetting</option>\n          <option value=\"KFGQPC Uthmanic Script HGFS\">KFGQPC Uthmanic Script HGFS</option>\n        </select>\n      </div>\n\n      <div className=\"panel__section\">\n        <span className=\"panel__label\">Bengali Font</span>\n        <select\n          className=\"form-select\"\n          value={style.bengaliFont}\n          onChange={(e) => setCaptionStyle({ bengaliFont: e.target.value })}\n        >\n          <option value=\"Noto Sans Bengali\">Noto Sans Bengali</option>\n          <option value=\"Hind Siliguri\">Hind Siliguri</option>\n          <option value=\"Noto Serif Bengali\">Noto Serif Bengali</option>\n          <option value=\"Kalpurush\">Kalpurush</option>\n          <option value=\"Siyam Rupali\">Siyam Rupali</option>\n          <option value=\"SolaimanLipi\">SolaimanLipi</option>\n          <option value=\"Vrinda\">Vrinda</option>\n        </select>\n      </div>\n\n      <div className=\"form-row\">\n        <div className=\"form-group\">\n          <label>Arabic Size</label>\n          <input\n            type=\"number\"\n            className=\"form-input\"\n            value={style.arabicSize}\n            min={16}\n            max={120}\n            onChange={(e) => setCaptionStyle({ arabicSize: parseInt(e.target.value) || 48 })}\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Bengali Size</label>\n          <input\n            type=\"number\"\n            className=\"form-input\"\n            value={style.bengaliSize}\n            min={12}\n            max={96}\n            onChange={(e) => setCaptionStyle({ bengaliSize: parseInt(e.target.value) || 36 })}\n          />\n        </div>\n      </div>\n\n      <div className=\"form-row\">\n        <div className=\"form-group\">\n          <label>Arabic Color</label>\n          <input\n            type=\"color\"\n            className=\"color-input\"\n            value={style.arabicColor}\n            onChange={(e) => setCaptionStyle({ arabicColor: e.target.value })}\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Bengali Color</label>\n          <input\n            type=\"color\"\n            className=\"color-input\"\n            value={style.bengaliColor}\n            onChange={(e) => setCaptionStyle({ bengaliColor: e.target.value })}\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Stroke</label>\n          <input\n            type=\"color\"\n            className=\"color-input\"\n            value={style.strokeColor}\n            onChange={(e) => setCaptionStyle({ strokeColor: e.target.value })}\n          />\n        </div>\n      </div>\n\n      <div className=\"form-group\">\n        <label>Gap Between Arabic & Bengali ({style.gap}px)</label>\n        <input\n          type=\"range\"\n          className=\"form-range\"\n          min={0}\n          max={60}\n          value={style.gap}\n          onChange={(e) => setCaptionStyle({ gap: parseInt(e.target.value) })}\n        />\n      </div>\n\n      <div className=\"form-group\">\n        <label>Caption Y Position ({style.positionY}%)</label>\n        <input\n          type=\"range\"\n          className=\"form-range\"\n          min={10}\n          max={90}\n          value={style.positionY}\n          onChange={(e) => setCaptionStyle({ positionY: parseInt(e.target.value) })}\n        />\n      </div>\n\n      <div className=\"form-row\">\n        <div className=\"form-group\">\n          <label>Stroke Width</label>\n          <input\n            type=\"number\"\n            className=\"form-input\"\n            value={style.strokeWidth}\n            min={0}\n            max={10}\n            onChange={(e) => setCaptionStyle({ strokeWidth: parseInt(e.target.value) || 0 })}\n          />\n        </div>\n        <div className=\"form-group\">\n          <label>Shadow Blur</label>\n          <input\n            type=\"number\"\n            className=\"form-input\"\n            value={style.shadowBlur}\n            min={0}\n            max={30}\n            onChange={(e) => setCaptionStyle({ shadowBlur: parseInt(e.target.value) || 0 })}\n          />\n        </div>\n      </div>\n\n      <div className=\"panel__section\">\n        <span className=\"panel__label\">Animation</span>\n        <select\n          className=\"form-select\"\n          value={style.animation || 'none'}\n          onChange={(e) => setCaptionStyle({ animation: e.target.value as any })}\n        >\n          <option value=\"none\">None</option>\n          <option value=\"fade-in\">Fade In (Simple)</option>\n          <option value=\"cinematic\">Cinematic (Slow Fade)</option>\n          <option value=\"typewriter\">Typewriter (Fast)</option>\n          <option value=\"pop-in\">Pop In (Fast)</option>\n          <option value=\"slide-up\">Slide Up</option>\n          <option value=\"slide-down\">Slide Down</option>\n          <option value=\"slide-left\">Slide Left</option>\n          <option value=\"slide-right\">Slide Right</option>\n          <option value=\"bounce-up\">Bounce Up</option>\n          <option value=\"bounce-down\">Bounce Down</option>\n          <option value=\"elastic-left\">Elastic Left</option>\n          <option value=\"elastic-right\">Elastic Right</option>\n          <option value=\"zoom-in\">Zoom In</option>\n          <option value=\"zoom-out\">Zoom Out</option>\n        </select>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\CaptionTimingEditor.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":20,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":20,"endColumn":36}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback } from 'react'\nimport { useEditorStore } from '../stores/editorStore'\n\nfunction formatTime(seconds: number): string {\n  const m = Math.floor(seconds / 60)\n  const s = seconds % 60\n  return `${m}:${s.toFixed(1).padStart(4, '0')}`\n}\n\nfunction parseTime(str: string): number | null {\n  // Accept formats: \"1:23.4\", \"83.4\", \"1:23\"\n  const colonMatch = str.match(/^(\\d+):(\\d+\\.?\\d*)$/)\n  if (colonMatch) {\n    return parseInt(colonMatch[1]) * 60 + parseFloat(colonMatch[2])\n  }\n  const num = parseFloat(str)\n  return isNaN(num) ? null : num\n}\n\nexport function CaptionTimingEditor() {\n  const captions = useEditorStore((s) => s.captions)\n  const updateCaption = useEditorStore((s) => s.updateCaption)\n  const setCurrentTime = useEditorStore((s) => s.setCurrentTime)\n  const [expandedId, setExpandedId] = useState<string | null>(null)\n\n  const handleTimeChange = useCallback(\n    (id: string, field: 'start' | 'end', value: string) => {\n      const t = parseTime(value)\n      if (t !== null && t >= 0) {\n        updateCaption(id, { [field]: Math.round(t * 10) / 10 })\n      }\n    },\n    [updateCaption]\n  )\n\n  const handleSeek = useCallback(\n    (time: number) => {\n      setCurrentTime(time)\n    },\n    [setCurrentTime]\n  )\n\n  if (captions.length === 0) {\n    return (\n      <div className=\"caption-timing-editor\">\n        <div className=\"caption-timing-editor__empty\">\n          No captions loaded yet. Use <strong>‚ú® AI Captions</strong> to generate them.\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"caption-timing-editor\">\n      <div className=\"caption-timing-editor__header\">\n        <span>üìù Caption Timing ({captions.length})</span>\n      </div>\n      <div className=\"caption-timing-editor__list\">\n        {captions.map((cap, i) => {\n          const isExpanded = expandedId === cap.id\n          const duration = cap.end - cap.start\n          return (\n            <div\n              key={cap.id}\n              className={`caption-item ${isExpanded ? 'caption-item--expanded' : ''}`}\n            >\n              <div\n                className=\"caption-item__summary\"\n                onClick={() => setExpandedId(isExpanded ? null : cap.id)}\n              >\n                <span className=\"caption-item__index\">#{i + 1}</span>\n                <span className=\"caption-item__preview\" dir=\"rtl\">\n                  {cap.arabicLines?.[0]?.substring(0, 25) || cap.arabic?.substring(0, 25) || '‚Äî'}\n                </span>\n                <span className=\"caption-item__duration\">{duration.toFixed(1)}s</span>\n              </div>\n\n              {isExpanded && (\n                <div className=\"caption-item__details\">\n                  <div className=\"caption-item__time-row\">\n                    <div className=\"caption-item__time-field\">\n                      <label>Start</label>\n                      <input\n                        type=\"text\"\n                        className=\"form-input form-input--sm\"\n                        defaultValue={formatTime(cap.start)}\n                        onBlur={(e) => handleTimeChange(cap.id, 'start', e.target.value)}\n                        onKeyDown={(e) => {\n                          if (e.key === 'Enter') {\n                            ;(e.target as HTMLInputElement).blur()\n                          }\n                        }}\n                      />\n                      <button\n                        className=\"btn btn--ghost btn--xs\"\n                        title=\"Seek to start\"\n                        onClick={() => handleSeek(cap.start)}\n                      >\n                        ‚ñ∂\n                      </button>\n                    </div>\n                    <div className=\"caption-item__time-field\">\n                      <label>End</label>\n                      <input\n                        type=\"text\"\n                        className=\"form-input form-input--sm\"\n                        defaultValue={formatTime(cap.end)}\n                        onBlur={(e) => handleTimeChange(cap.id, 'end', e.target.value)}\n                        onKeyDown={(e) => {\n                          if (e.key === 'Enter') {\n                            ;(e.target as HTMLInputElement).blur()\n                          }\n                        }}\n                      />\n                      <button\n                        className=\"btn btn--ghost btn--xs\"\n                        title=\"Seek to end\"\n                        onClick={() => handleSeek(cap.end)}\n                      >\n                        ‚ñ∂\n                      </button>\n                    </div>\n                  </div>\n\n                  <div className=\"caption-item__nudge-row\">\n                    <button\n                      className=\"btn btn--ghost btn--xs\"\n                      title=\"Shift start -0.5s\"\n                      onClick={() => updateCaption(cap.id, { start: Math.max(0, cap.start - 0.5) })}\n                    >\n                      ‚óÄ -0.5s\n                    </button>\n                    <button\n                      className=\"btn btn--ghost btn--xs\"\n                      title=\"Shift start +0.5s\"\n                      onClick={() => updateCaption(cap.id, { start: cap.start + 0.5 })}\n                    >\n                      +0.5s ‚ñ∂\n                    </button>\n                    <span className=\"caption-item__sep\">|</span>\n                    <button\n                      className=\"btn btn--ghost btn--xs\"\n                      title=\"Shift end -0.5s\"\n                      onClick={() =>\n                        updateCaption(cap.id, { end: Math.max(cap.start + 0.1, cap.end - 0.5) })\n                      }\n                    >\n                      ‚óÄ -0.5s\n                    </button>\n                    <button\n                      className=\"btn btn--ghost btn--xs\"\n                      title=\"Shift end +0.5s\"\n                      onClick={() => updateCaption(cap.id, { end: cap.end + 0.5 })}\n                    >\n                      +0.5s ‚ñ∂\n                    </button>\n                  </div>\n\n                  <div className=\"caption-item__text-preview\">\n                    <div className=\"caption-item__text-block\" dir=\"rtl\">\n                      <small>Arabic</small>\n                      <p>{cap.arabicLines?.join(' ') || cap.arabic}</p>\n                    </div>\n                    <div className=\"caption-item__text-block\">\n                      <small>Bengali</small>\n                      <p>{cap.bengaliLines?.join(' ') || cap.bengali}</p>\n                    </div>\n                  </div>\n                </div>\n              )}\n            </div>\n          )\n        })}\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\RenderDialog.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":4,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":4,"endColumn":29}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useCallback, useRef } from 'react'\nimport { useEditorStore } from '../stores/editorStore'\n\nexport function RenderDialog() {\n  const isRendering = useEditorStore((s) => s.isRendering)\n  const renderProgress = useEditorStore((s) => s.renderProgress)\n  const renderDiagnostics = useEditorStore((s) => s.renderDiagnostics)\n  const setIsRendering = useEditorStore((s) => s.setIsRendering)\n  const setRenderProgress = useEditorStore((s) => s.setRenderProgress)\n  const diagnosticsRef = useRef<HTMLDivElement>(null)\n\n  // Listeners removed: Progress is now updated directly by the renderer via the store.\n\n  useEffect(() => {\n    const el = diagnosticsRef.current\n    if (!el) return\n    el.scrollTop = el.scrollHeight\n  }, [renderDiagnostics])\n\n  const handleCancel = useCallback(async () => {\n    // TODO: Implement abortion for browserRender if needed.\n    // For now, just close the dialog.\n    setIsRendering(false)\n    setRenderProgress(0)\n  }, [setIsRendering, setRenderProgress])\n\n  const handleCopyLogs = useCallback(async () => {\n    const text = renderDiagnostics.join('\\n')\n    if (!text) return\n    try {\n      await navigator.clipboard.writeText(text)\n    } catch {\n      // Ignore clipboard failures.\n    }\n  }, [renderDiagnostics])\n\n  if (!isRendering) return null\n\n  return (\n    <div className=\"modal-overlay\">\n      <div className=\"modal render-dialog-modal\">\n        <div className=\"modal__header\">\n          <h3 className=\"modal__title\">Rendering</h3>\n        </div>\n        <div className=\"modal__body render-dialog\">\n          <div className=\"render-dialog__percent\">{Math.round(renderProgress)}%</div>\n          <div className=\"render-dialog__progress\">\n            <div className=\"render-dialog__progress-bar\" style={{ width: `${renderProgress}%` }} />\n          </div>\n          <div className=\"render-dialog__status\">\n            {renderProgress < 100 ? 'Encoding video...' : 'Finalizing...'}\n          </div>\n\n          <div className=\"render-diagnostics\">\n            <div className=\"render-diagnostics__header\">\n              <span>Render Diagnostics</span>\n              <button className=\"btn btn--ghost btn--sm\" onClick={handleCopyLogs}>\n                Copy Logs\n              </button>\n            </div>\n            <div className=\"render-diagnostics__body\" ref={diagnosticsRef}>\n              {renderDiagnostics.length === 0 ? (\n                <div className=\"render-diagnostics__empty\">Waiting for FFmpeg output...</div>\n              ) : (\n                renderDiagnostics.map((line, idx) => (\n                  <div key={`${idx}-${line}`} className=\"render-diagnostics__line\">\n                    {line}\n                  </div>\n                ))\n              )}\n            </div>\n          </div>\n        </div>\n        <div className=\"modal__footer\" style={{ justifyContent: 'center' }}>\n          <button className=\"btn btn--danger\" onClick={handleCancel}>\n            Cancel Render\n          </button>\n        </div>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\SettingsModal.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":8,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":8,"endColumn":30}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useCallback, useEffect } from 'react'\n\ninterface SettingsModalProps {\n  isOpen: boolean\n  onClose: () => void\n}\n\nexport function SettingsModal({ isOpen, onClose }: SettingsModalProps) {\n  const [apiKey, setApiKey] = useState('')\n  const [testResult, setTestResult] = useState<{ success: boolean; message: string } | null>(null)\n  const [isTesting, setIsTesting] = useState(false)\n\n  useEffect(() => {\n    if (!isOpen) return\n    window.api.store.get('geminiApiKey').then((key) => {\n      setApiKey(String(key || ''))\n    })\n  }, [isOpen])\n\n  const handleSave = useCallback(async () => {\n    await window.api.store.set('geminiApiKey', apiKey.trim())\n    onClose()\n  }, [apiKey, onClose])\n\n  const handleTest = useCallback(async () => {\n    setIsTesting(true)\n    setTestResult(null)\n    await window.api.store.set('geminiApiKey', apiKey.trim())\n    const result = await window.api.gemini.testConnection()\n    setTestResult(result)\n    setIsTesting(false)\n  }, [apiKey])\n\n  if (!isOpen) return null\n\n  return (\n    <div className=\"modal-overlay\" onClick={onClose}>\n      <div className=\"modal\" onClick={(e) => e.stopPropagation()}>\n        <div className=\"modal__header\">\n          <h3 className=\"modal__title\">Settings</h3>\n          <button className=\"btn btn--ghost btn--icon\" onClick={onClose}>\n            X\n          </button>\n        </div>\n        <div className=\"modal__body\">\n          <div className=\"form-group\">\n            <label>Local OCR Engine</label>\n            <div className=\"panel__value\" style={{ fontSize: '12px', lineHeight: 1.5 }}>\n              Captions are extracted locally with Tesseract (offline). Required language packs:\n              Arabic (`ara`) and Bengali (`ben`).\n            </div>\n          </div>\n\n          <div className=\"form-group\">\n            <label>Gemini API Key (Optional)</label>\n            <input\n              type=\"password\"\n              className=\"form-input\"\n              placeholder=\"Used only for automatic Surah/Ayah metadata\"\n              value={apiKey}\n              onChange={(e) => setApiKey(e.target.value)}\n            />\n          </div>\n\n          <div className=\"form-row\">\n            <button className=\"btn\" onClick={handleTest} disabled={isTesting}>\n              {isTesting ? (\n                <>\n                  <span className=\"spinner\" /> Checking...\n                </>\n              ) : (\n                'Check OCR + Gemini'\n              )}\n            </button>\n          </div>\n\n          {testResult && (\n            <div className={`badge ${testResult.success ? 'badge--success' : 'badge--error'}`}>\n              {testResult.success ? 'OK' : 'FAIL'} {testResult.message}\n            </div>\n          )}\n\n          <hr style={{ border: 'none', borderTop: '1px solid var(--border-color)' }} />\n\n          <div className=\"panel__section\">\n            <span className=\"panel__label\">About</span>\n            <p className=\"panel__value\" style={{ fontSize: '11px' }}>\n              Quran Video Editor v1.0.0\n              <br />\n              Local OCR captions + optional Gemini metadata\n              <br />\n              Hardware accelerated with Intel Arc QSV\n            </p>\n          </div>\n        </div>\n        <div className=\"modal__footer\">\n          <button className=\"btn\" onClick={onClose}>\n            Cancel\n          </button>\n          <button className=\"btn btn--primary\" onClick={handleSave}>\n            Save\n          </button>\n        </div>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\Sidebar.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":6,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":6,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":451,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":451,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16929,16932],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16929,16932],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback, useEffect, useState } from 'react'\nimport { useEditorStore, RenderSettings, WatermarkConfig } from '../stores/editorStore'\nimport { CaptionControls } from './CaptionControls'\nimport { CaptionTimingEditor } from './CaptionTimingEditor'\n\nexport function Sidebar() {\n  const activePanel = useEditorStore((s) => s.activePanel)\n  const setActivePanel = useEditorStore((s) => s.setActivePanel)\n  const videoPath = useEditorStore((s) => s.videoPath)\n  const audioPath = useEditorStore((s) => s.audioPath)\n  const setVideoPath = useEditorStore((s) => s.setVideoPath)\n  const setAudioPath = useEditorStore((s) => s.setAudioPath)\n  const setVideoDuration = useEditorStore((s) => s.setVideoDuration)\n  const setAudioDuration = useEditorStore((s) => s.setAudioDuration)\n  const setVideoResolution = useEditorStore((s) => s.setVideoResolution)\n  const watermark = useEditorStore((s) => s.watermark)\n  const setWatermark = useEditorStore((s) => s.setWatermark)\n  const renderSettings = useEditorStore((s) => s.renderSettings)\n  const setRenderSettings = useEditorStore((s) => s.setRenderSettings)\n  const geminiStatus = useEditorStore((s) => s.geminiStatus)\n  const captions = useEditorStore((s) => s.captions)\n  const aspectRatio = useEditorStore((s) => s.aspectRatio)\n  const setAspectRatio = useEditorStore((s) => s.setAspectRatio)\n\n  const [dragOverType, setDragOverType] = useState<'video' | 'audio' | 'watermark' | null>(null)\n\n  const probeMedia = async (\n    path: string\n  ): Promise<{ duration: number; width: number; height: number }> => {\n    return new Promise<{ duration: number; width: number; height: number }>((resolve, reject) => {\n      const video = document.createElement('video')\n      video.preload = 'metadata'\n      video.src = `file://${path}`\n      video.onloadedmetadata = () => {\n        resolve({\n          duration: video.duration,\n          width: video.videoWidth,\n          height: video.videoHeight\n        })\n        video.remove()\n      }\n      video.onerror = (e) => reject(e)\n    })\n  }\n\n  const handleImportVideo = useCallback(async () => {\n    const path = await window.api.dialog.openFile([\n      { name: 'Video', extensions: ['mp4', 'mkv', 'webm', 'avi', 'mov'] }\n    ])\n    if (path) {\n      setVideoPath(path)\n      try {\n        // Use client-side probing\n        const info = await probeMedia(path)\n        setVideoDuration(info.duration)\n        setVideoResolution(info.width, info.height)\n      } catch (e) {\n        console.warn('Could not probe video:', e)\n      }\n    }\n  }, [setVideoPath, setVideoDuration, setVideoResolution])\n\n  const handleImportAudio = useCallback(async () => {\n    // Allow video files too, since we extract audio from them\n    const path = await window.api.dialog.openFile([\n      { name: 'Media Files', extensions: ['mp3', 'wav', 'mp4', 'mkv', 'mov', 'avi'] }\n    ])\n    if (path) {\n      // Determine if it's video or audio based on extension for preview logic\n      // But mainly we treat it as audio source.\n      setAudioPath(path)\n\n      // Get duration of reference\n      try {\n        const info = await probeMedia(path)\n        setAudioDuration(info.duration)\n      } catch (e) {\n        console.warn('Could not probe audio:', e)\n      }\n    }\n  }, [setAudioPath, setAudioDuration])\n\n  const handleImportWatermark = useCallback(async () => {\n    const path = await window.api.dialog.openFile([\n      { name: 'Image', extensions: ['png', 'jpg', 'jpeg', 'webp'] }\n    ])\n    if (path) {\n      const newWm = {\n        path,\n        x: 20,\n        y: 20,\n        width: 120,\n        height: 120,\n        opacity: 0.8\n      }\n      setWatermark(newWm)\n      window.api.store.set('watermark', newWm)\n    }\n  }, [setWatermark])\n\n  // Load persisted watermark on mount\n  useEffect(() => {\n    window.api.store.get('watermark').then((wm: unknown) => {\n      if (wm) setWatermark(wm as WatermarkConfig)\n    })\n  }, [setWatermark])\n\n  const handleDragOver = useCallback(\n    (e: React.DragEvent, type: 'video' | 'audio' | 'watermark') => {\n      e.preventDefault()\n      e.stopPropagation()\n      setDragOverType(type)\n    },\n    []\n  )\n\n  const handleDragLeave = useCallback((e: React.DragEvent) => {\n    e.preventDefault()\n    e.stopPropagation()\n    setDragOverType(null)\n  }, [])\n\n  const handleDrop = useCallback(\n    async (e: React.DragEvent, type: 'video' | 'audio' | 'watermark') => {\n      e.preventDefault()\n      e.stopPropagation()\n      setDragOverType(null)\n\n      if (!e.dataTransfer.files || e.dataTransfer.files.length === 0) return\n      const file = e.dataTransfer.files[0]\n\n      // Electron adds 'path' property to File objects, but needs webUtils in newer versions\n      const path = window.api.files.getPath(file)\n      if (!path) return\n\n      if (type === 'video') {\n        setVideoPath(path)\n        try {\n          const info = await probeMedia(path)\n          setVideoDuration(info.duration)\n          setVideoResolution(info.width, info.height)\n        } catch (err) {\n          console.warn('Could not probe dropped video:', err)\n        }\n      } else if (type === 'audio') {\n        setAudioPath(path)\n        try {\n          const info = await probeMedia(path)\n          setAudioDuration(info.duration)\n        } catch (err) {\n          console.warn('Could not probe dropped audio:', err)\n        }\n      } else if (type === 'watermark') {\n        const newWm = {\n          path,\n          x: 20,\n          y: 20,\n          width: 120,\n          height: 120,\n          opacity: 0.8\n        }\n        setWatermark(newWm)\n        window.api.store.set('watermark', newWm)\n      }\n    },\n    [\n      setVideoPath,\n      setVideoDuration,\n      setVideoResolution,\n      setAudioPath,\n      setAudioDuration,\n      setWatermark\n    ]\n  )\n\n  const tabs = [\n    { id: 'media' as const, label: 'Media' },\n    { id: 'captions' as const, label: 'Captions' },\n    { id: 'watermark' as const, label: 'Logo' },\n    { id: 'render' as const, label: 'Render' }\n  ]\n\n  return (\n    <div className=\"sidebar\">\n      <div className=\"sidebar__tabs\">\n        {tabs.map((tab) => (\n          <button\n            key={tab.id}\n            className={`sidebar__tab ${activePanel === tab.id ? 'sidebar__tab--active' : ''}`}\n            onClick={() => setActivePanel(tab.id)}\n          >\n            {tab.label}\n          </button>\n        ))}\n      </div>\n\n      <div className=\"sidebar__content\">\n        {/* ‚îÄ‚îÄ‚îÄ Media Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}\n        {activePanel === 'media' && (\n          <div className=\"panel\">\n            <div\n              className={`dropzone ${videoPath ? 'dropzone--loaded' : ''} ${dragOverType === 'video' ? 'dropzone--drag-over' : ''}`}\n              onClick={handleImportVideo}\n              onDragOver={(e) => handleDragOver(e, 'video')}\n              onDragLeave={handleDragLeave}\n              onDrop={(e) => handleDrop(e, 'video')}\n            >\n              <div className=\"dropzone__icon\">üé•</div>\n              <div className=\"dropzone__text\">\n                {videoPath ? videoPath.split(/[\\\\/]/).pop() : 'Import Background Video'}\n              </div>\n              <div className=\"dropzone__hint\">MP4, MKV, WebM, AVI, MOV</div>\n            </div>\n\n            <div\n              className={`dropzone ${audioPath ? 'dropzone--loaded' : ''} ${dragOverType === 'audio' ? 'dropzone--drag-over' : ''}`}\n              onClick={handleImportAudio}\n              onDragOver={(e) => handleDragOver(e, 'audio')}\n              onDragLeave={handleDragLeave}\n              onDrop={(e) => handleDrop(e, 'audio')}\n            >\n              <div className=\"dropzone__icon\">üéµ</div>\n              <div className=\"dropzone__text\">\n                {audioPath ? audioPath.split(/[\\\\\\\\/]/).pop() : 'Import Reference Video (Quran)'}\n              </div>\n              <div className=\"dropzone__hint\">MP4, MKV, MOV, AVI, MP3, WAV</div>\n            </div>\n\n            {geminiStatus && (\n              <div className=\"panel__section\">\n                <span className=\"panel__label\">AI Status</span>\n                <span\n                  className={`badge ${geminiStatus.includes('Error') ? 'badge--error' : 'badge--info'}`}\n                >\n                  {geminiStatus}\n                </span>\n              </div>\n            )}\n\n            {captions.length > 0 && (\n              <div className=\"panel__section\">\n                <span className=\"panel__label\">Captions</span>\n                <span className=\"badge badge--success\">‚úì {captions.length} segments loaded</span>\n              </div>\n            )}\n\n            <div className=\"panel__section\" style={{ marginTop: 'auto', paddingTop: 16 }}>\n              <button\n                className=\"btn btn--secondary btn--sm\"\n                style={{ width: '100%', opacity: 0.8 }}\n                onClick={async () => {\n                  const { getTestCaptions, getTestMetadata } = await import('../utils/testData')\n                  const testCaps = getTestCaptions()\n                  const testMeta = getTestMetadata()\n                  useEditorStore.getState().setCaptions(testCaps)\n                  useEditorStore.getState().setMetadata(testMeta)\n                  useEditorStore.getState().setGeminiStatus('Test Data Loaded')\n                }}\n              >\n                ‚ö° Load Test Data (No API)\n              </button>\n            </div>\n          </div>\n        )}\n\n        {/* ‚îÄ‚îÄ‚îÄ Captions Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}\n        {activePanel === 'captions' && (\n          <>\n            <CaptionControls />\n            <CaptionTimingEditor />\n          </>\n        )}\n\n        {/* ‚îÄ‚îÄ‚îÄ Watermark Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}\n        {activePanel === 'watermark' && (\n          <div className=\"panel\">\n            <div\n              className={`dropzone ${watermark ? 'dropzone--loaded' : ''} ${dragOverType === 'watermark' ? 'dropzone--drag-over' : ''}`}\n              onClick={handleImportWatermark}\n              onDragOver={(e) => handleDragOver(e, 'watermark')}\n              onDragLeave={handleDragLeave}\n              onDrop={(e) => handleDrop(e, 'watermark')}\n            >\n              <div className=\"dropzone__icon\">üñºÔ∏è</div>\n              <div className=\"dropzone__text\">\n                {watermark ? watermark.path.split(/[\\\\/]/).pop() : 'Import Watermark / Logo'}\n              </div>\n              <div className=\"dropzone__hint\">PNG, JPG, WebP</div>\n            </div>\n\n            {watermark && (\n              <>\n                <div className=\"form-group\">\n                  <label>Opacity ({Math.round(watermark.opacity * 100)}%)</label>\n                  <input\n                    type=\"range\"\n                    className=\"form-range\"\n                    min={0}\n                    max={100}\n                    value={watermark.opacity * 100}\n                    onChange={(e) =>\n                      setWatermark({ ...watermark, opacity: parseInt(e.target.value) / 100 })\n                    }\n                  />\n                </div>\n                <div className=\"form-row\">\n                  <div className=\"form-group\">\n                    <label>Position X</label>\n                    <input\n                      type=\"number\"\n                      className=\"form-input\"\n                      value={watermark.x}\n                      onChange={(e) => {\n                        const newWm = { ...watermark, x: parseInt(e.target.value) || 0 }\n                        setWatermark(newWm)\n                        window.api.store.set('watermark', newWm)\n                      }}\n                    />\n                  </div>\n                  <div className=\"form-group\">\n                    <label>Position Y</label>\n                    <input\n                      type=\"number\"\n                      className=\"form-input\"\n                      value={watermark.y}\n                      onChange={(e) => {\n                        const newWm = { ...watermark, y: parseInt(e.target.value) || 0 }\n                        setWatermark(newWm)\n                        window.api.store.set('watermark', newWm)\n                      }}\n                    />\n                  </div>\n                </div>\n                <div className=\"form-row\">\n                  <div className=\"form-group\">\n                    <label>Width</label>\n                    <input\n                      type=\"number\"\n                      className=\"form-input\"\n                      value={watermark.width}\n                      onChange={(e) => {\n                        const newWm = { ...watermark, width: parseInt(e.target.value) || 100 }\n                        setWatermark(newWm)\n                        window.api.store.set('watermark', newWm)\n                      }}\n                    />\n                  </div>\n                  <div className=\"form-group\">\n                    <label>Height</label>\n                    <input\n                      type=\"number\"\n                      className=\"form-input\"\n                      value={watermark.height}\n                      onChange={(e) => {\n                        const newWm = { ...watermark, height: parseInt(e.target.value) || 100 }\n                        setWatermark(newWm)\n                        window.api.store.set('watermark', newWm)\n                      }}\n                    />\n                  </div>\n                </div>\n                <button\n                  className=\"btn btn--danger btn--sm\"\n                  onClick={() => {\n                    setWatermark(null)\n                    window.api.store.set('watermark', null)\n                  }}\n                >\n                  Remove Watermark\n                </button>\n              </>\n            )}\n          </div>\n        )}\n\n        {/* ‚îÄ‚îÄ‚îÄ Render Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */}\n        {activePanel === 'render' && (\n          <div className=\"panel\">\n            <div className=\"form-group\">\n              <label>Aspect Ratio</label>\n              <select\n                className=\"form-input\"\n                value={aspectRatio}\n                onChange={(e) => setAspectRatio(e.target.value as '16:9' | '9:16' | '1:1')}\n              >\n                <option value=\"16:9\">Horizontal (16:9) - 1920x1080</option>\n                <option value=\"9:16\">Vertical (9:16) - 1080x1920</option>\n                <option value=\"1:1\">Square (1:1) - 1080x1080</option>\n              </select>\n            </div>\n            <div className=\"form-group\">\n              <label>Video Encoder</label>\n              <select\n                className=\"form-select\"\n                value={renderSettings.encoder}\n                onChange={(e) =>\n                  setRenderSettings({ encoder: e.target.value as RenderSettings['encoder'] })\n                }\n              >\n                <option value=\"av1_qsv\">AV1 (Intel Arc QSV) ‚ö°</option>\n                <option value=\"hevc_qsv\">HEVC (Intel Arc QSV) ‚ö°</option>\n                <option value=\"libsvtav1\">AV1 (Software - SVT)</option>\n                <option value=\"libx265\">HEVC (Software - x265)</option>\n              </select>\n            </div>\n\n            <div className=\"form-group\">\n              <label>Bitrate</label>\n              <select\n                className=\"form-select\"\n                value={renderSettings.bitrate}\n                onChange={(e) => setRenderSettings({ bitrate: e.target.value })}\n              >\n                <option value=\"4M\">4 Mbps (Small)</option>\n                <option value=\"8M\">8 Mbps (Standard)</option>\n                <option value=\"15M\">15 Mbps (High)</option>\n                <option value=\"25M\">25 Mbps (Ultra)</option>\n              </select>\n            </div>\n\n            <div\n              className={`toggle ${renderSettings.enableSlowMo ? 'toggle--active' : ''}`}\n              onClick={() => setRenderSettings({ enableSlowMo: !renderSettings.enableSlowMo })}\n            >\n              <div className=\"toggle__switch\" />\n              <span className=\"toggle__label\">üé• Optical Flow Slow-Mo</span>\n            </div>\n\n            {renderSettings.enableSlowMo && (\n              <div className=\"form-group\">\n                <label>Target FPS</label>\n                <select\n                  className=\"form-select\"\n                  value={renderSettings.slowMoFps}\n                  onChange={(e) => setRenderSettings({ slowMoFps: parseInt(e.target.value) })}\n                >\n                  <option value={30}>30 FPS</option>\n                  <option value={60}>60 FPS</option>\n                  <option value={120}>120 FPS</option>\n                </select>\n              </div>\n            )}\n\n            <div className=\"panel__section\">\n              <span className=\"panel__label\">Visual Effects</span>\n              <div className=\"form-group\">\n                <label>Video Filter</label>\n                <select\n                  className=\"form-select\"\n                  value={renderSettings.videoFilter}\n                  onChange={(e) => setRenderSettings({ videoFilter: e.target.value as any })}\n                >\n                  <option value=\"none\">None (Original)</option>\n                  <option value=\"cinematic\">Cinematic (Vintage)</option>\n                  <option value=\"warm\">Warm (Sunset)</option>\n                  <option value=\"cool\">Cool (Night)</option>\n                  <option value=\"bw\">Black & White</option>\n                </select>\n              </div>\n            </div>\n\n            <div className=\"panel__section\" style={{ marginTop: 8 }}>\n              <span className=\"panel__label\">Info</span>\n              <p className=\"panel__value\" style={{ fontSize: '11px', lineHeight: 1.5 }}>\n                ‚Ä¢ Video shorter than audio ‚Üí auto-loop with 1s crossfade\n                <br />\n                ‚Ä¢ Bengali_Y = Arabic_Y + Arabic_Height + Gap\n                <br />‚Ä¢ QSV encoders require Intel Arc GPU drivers\n              </p>\n            </div>\n          </div>\n        )}\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\Timeline.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":19,"column":1,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":19,"endColumn":22},{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":132,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":132,"endColumn":25}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useMemo, useCallback, useEffect, useState } from 'react'\nimport { useEditorStore, CaptionSegment } from '../stores/editorStore'\nimport { formatTimestamp } from '../utils/captionLayout'\n\nconst BASE_PPS = 80 // base pixels per second at zoom=1\nconst HANDLE_WIDTH = 6 // px ‚Äî drag handle hit zone on each edge\nconst MIN_DURATION = 0.2 // minimum caption duration in seconds\n\n/* ‚îÄ‚îÄ‚îÄ Draggable Caption Block ‚îÄ‚îÄ‚îÄ */\ninterface CaptionBlockProps {\n  cap: CaptionSegment\n  pxPerSec: number\n  totalDuration: number\n  variant: 'arabic' | 'bengali'\n  onDragStart: () => void\n  onDragEnd: () => void\n}\n\nfunction CaptionBlock({\n  cap,\n  pxPerSec,\n  totalDuration,\n  variant,\n  onDragStart,\n  onDragEnd\n}: CaptionBlockProps) {\n  const updateCaption = useEditorStore((s) => s.updateCaption)\n  const setCurrentTime = useEditorStore((s) => s.setCurrentTime)\n  const dragRef = useRef<{\n    type: 'left' | 'right' | 'move'\n    startX: number\n    origStart: number\n    origEnd: number\n  } | null>(null)\n\n  const blockLeft = cap.start * pxPerSec\n  const blockWidth = Math.max((cap.end - cap.start) * pxPerSec, 4)\n  const label = variant === 'arabic' ? cap.arabic : cap.bengali\n\n  const handleMouseDown = useCallback(\n    (e: React.MouseEvent, type: 'left' | 'right' | 'move') => {\n      e.stopPropagation()\n      e.preventDefault()\n      onDragStart()\n      dragRef.current = {\n        type,\n        startX: e.clientX,\n        origStart: cap.start,\n        origEnd: cap.end\n      }\n\n      const onMove = (ev: MouseEvent): void => {\n        if (!dragRef.current) return\n        const dx = ev.clientX - dragRef.current.startX\n        const dt = dx / pxPerSec\n        const { origStart, origEnd } = dragRef.current\n\n        if (dragRef.current.type === 'left') {\n          const newStart = Math.max(0, Math.min(origStart + dt, origEnd - MIN_DURATION))\n          updateCaption(cap.id, { start: Math.round(newStart * 10) / 10 })\n          setCurrentTime(Math.round(newStart * 10) / 10)\n        } else if (dragRef.current.type === 'right') {\n          const newEnd = Math.max(origStart + MIN_DURATION, Math.min(origEnd + dt, totalDuration))\n          updateCaption(cap.id, { end: Math.round(newEnd * 10) / 10 })\n          setCurrentTime(Math.round(newEnd * 10) / 10)\n        } else {\n          // move entire block\n          const dur = origEnd - origStart\n          let newStart = origStart + dt\n          newStart = Math.max(0, Math.min(newStart, totalDuration - dur))\n          const rounded = Math.round(newStart * 10) / 10\n          updateCaption(cap.id, { start: rounded, end: Math.round((rounded + dur) * 10) / 10 })\n          setCurrentTime(rounded)\n        }\n      }\n\n      const onUp = (): void => {\n        dragRef.current = null\n        document.removeEventListener('mousemove', onMove)\n        document.removeEventListener('mouseup', onUp)\n        document.body.style.cursor = ''\n        document.body.style.userSelect = ''\n        // Delay clearing drag flag so the body click doesn't fire\n        setTimeout(onDragEnd, 0)\n      }\n\n      document.body.style.cursor = type === 'left' || type === 'right' ? 'col-resize' : 'grabbing'\n      document.body.style.userSelect = 'none'\n      document.addEventListener('mousemove', onMove)\n      document.addEventListener('mouseup', onUp)\n    },\n    [\n      cap.id,\n      cap.start,\n      cap.end,\n      pxPerSec,\n      totalDuration,\n      updateCaption,\n      setCurrentTime,\n      onDragStart,\n      onDragEnd\n    ]\n  )\n\n  return (\n    <div\n      className={`timeline__caption-block timeline__caption-block--${variant}`}\n      style={{ left: blockLeft, width: blockWidth }}\n      title={label}\n    >\n      {/* Left edge handle */}\n      <div\n        className=\"timeline__drag-handle timeline__drag-handle--left\"\n        style={{ width: HANDLE_WIDTH }}\n        onMouseDown={(e) => handleMouseDown(e, 'left')}\n      />\n      {/* Middle: drag to move */}\n      <div className=\"timeline__drag-body\" onMouseDown={(e) => handleMouseDown(e, 'move')}>\n        {label}\n      </div>\n      {/* Right edge handle */}\n      <div\n        className=\"timeline__drag-handle timeline__drag-handle--right\"\n        style={{ width: HANDLE_WIDTH }}\n        onMouseDown={(e) => handleMouseDown(e, 'right')}\n      />\n    </div>\n  )\n}\n\n/* ‚îÄ‚îÄ‚îÄ Timeline ‚îÄ‚îÄ‚îÄ */\nexport function Timeline() {\n  const bodyRef = useRef<HTMLDivElement>(null)\n  const captions = useEditorStore((s) => s.captions)\n  const currentTime = useEditorStore((s) => s.currentTime)\n  const setCurrentTime = useEditorStore((s) => s.setCurrentTime)\n  const audioDuration = useEditorStore((s) => s.audioDuration)\n  const videoDuration = useEditorStore((s) => s.videoDuration)\n  const zoom = useEditorStore((s) => s.timelineZoom)\n  const setZoom = useEditorStore((s) => s.setTimelineZoom)\n\n  const [bodyWidth, setBodyWidth] = useState(800)\n  const isDraggingRef = useRef(false)\n\n  const maxCaptionEnd = captions.length > 0 ? Math.max(...captions.map((c) => c.end)) : 0\n  const totalDuration = Math.max(audioDuration, videoDuration, maxCaptionEnd + 2, 10)\n  const pxPerSec = BASE_PPS * zoom\n  const totalWidth = totalDuration * pxPerSec\n\n  const onDragStart = useCallback(() => {\n    isDraggingRef.current = true\n  }, [])\n  const onDragEnd = useCallback(() => {\n    isDraggingRef.current = false\n  }, [])\n\n  // Track body width for fit-to-view\n  useEffect(() => {\n    const el = bodyRef.current\n    if (!el) return\n    const obs = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        setBodyWidth(entry.contentRect.width)\n      }\n    })\n    obs.observe(el)\n    return () => obs.disconnect()\n  }, [])\n\n  // Auto-fit when duration changes (new captions loaded, new media)\n  useEffect(() => {\n    if (totalDuration > 10 && bodyWidth > 0) {\n      const fitZoom = bodyWidth / (totalDuration * BASE_PPS)\n      setZoom(Math.max(0.01, Math.min(fitZoom * 0.95, 5))) // 95% fill with margin\n    }\n  }, [totalDuration, bodyWidth, setZoom])\n\n  // Fit-to-view handler\n  const fitToView = useCallback(() => {\n    if (bodyWidth > 0 && totalDuration > 0) {\n      const fitZoom = bodyWidth / (totalDuration * BASE_PPS)\n      setZoom(Math.max(0.01, Math.min(fitZoom * 0.95, 5)))\n    }\n  }, [bodyWidth, totalDuration, setZoom])\n\n  // Smart ruler interval based on effective px/sec\n  const rulerMarks = useMemo(() => {\n    const marks: { time: number; x: number }[] = []\n    const targetSpacing = 80\n    const rawInterval = targetSpacing / pxPerSec\n    const niceIntervals = [0.5, 1, 2, 5, 10, 15, 30, 60, 120, 300, 600]\n    let interval = niceIntervals[niceIntervals.length - 1]\n    for (const ni of niceIntervals) {\n      if (ni >= rawInterval) {\n        interval = ni\n        break\n      }\n    }\n    for (let t = 0; t <= totalDuration; t += interval) {\n      marks.push({ time: t, x: t * pxPerSec })\n    }\n    return marks\n  }, [totalDuration, pxPerSec])\n\n  const handleBodyClick = useCallback(\n    (e: React.MouseEvent) => {\n      // Don't seek when finishing a drag\n      if (isDraggingRef.current) return\n      const rect = bodyRef.current?.getBoundingClientRect()\n      if (!rect) return\n      const x = e.clientX - rect.left + (bodyRef.current?.scrollLeft || 0)\n      const time = Math.max(0, Math.min(x / pxPerSec, totalDuration))\n      setCurrentTime(time)\n    },\n    [pxPerSec, totalDuration, setCurrentTime]\n  )\n\n  const handleWheel = useCallback(\n    (e: WheelEvent) => {\n      if (e.ctrlKey) {\n        e.preventDefault()\n        const factor = e.deltaY > 0 ? 0.85 : 1.18\n        setZoom(Math.max(0.01, Math.min(zoom * factor, 10)))\n      }\n    },\n    [zoom, setZoom]\n  )\n\n  // Attach wheel listener with { passive: false } to allow preventDefault\n  useEffect(() => {\n    const el = bodyRef.current\n    if (!el) return\n    el.addEventListener('wheel', handleWheel, { passive: false })\n    return () => el.removeEventListener('wheel', handleWheel)\n  }, [handleWheel])\n\n  // Auto-scroll to keep playhead visible\n  useEffect(() => {\n    const el = bodyRef.current\n    if (!el) return\n    const px = currentTime * pxPerSec\n    const scrollLeft = el.scrollLeft\n    const viewWidth = el.clientWidth\n    if (px < scrollLeft + 20 || px > scrollLeft + viewWidth - 20) {\n      el.scrollLeft = px - viewWidth / 3\n    }\n  }, [currentTime, pxPerSec])\n\n  const playheadX = currentTime * pxPerSec\n\n  return (\n    <div className=\"timeline\">\n      <div className=\"timeline__header\">\n        <span className=\"timeline__header-title\">Timeline</span>\n        <div className=\"timeline__zoom\">\n          <button\n            className=\"btn btn--ghost btn--sm\"\n            onClick={() => setZoom(Math.max(0.01, zoom * 0.7))}\n            title=\"Zoom out\"\n          >\n            ‚àí\n          </button>\n          <button\n            className=\"btn btn--ghost btn--sm\"\n            onClick={fitToView}\n            title=\"Fit to view\"\n            style={{ fontSize: '10px', padding: '2px 6px' }}\n          >\n            FIT\n          </button>\n          <button\n            className=\"btn btn--ghost btn--sm\"\n            onClick={() => setZoom(Math.min(10, zoom * 1.4))}\n            title=\"Zoom in\"\n          >\n            +\n          </button>\n          <span style={{ minWidth: 40, textAlign: 'center' }}>{Math.round(zoom * 100)}%</span>\n        </div>\n      </div>\n\n      <div className=\"timeline__body\" ref={bodyRef} onClick={handleBodyClick}>\n        {/* Ruler */}\n        <div className=\"timeline__ruler\" style={{ width: totalWidth }}>\n          {rulerMarks.map((m) => (\n            <div key={m.time} className=\"timeline__ruler-mark\" style={{ left: m.x }}>\n              {formatTimestamp(m.time)}\n            </div>\n          ))}\n        </div>\n\n        {/* Tracks */}\n        <div className=\"timeline__tracks\" style={{ width: totalWidth }}>\n          {/* Waveform track */}\n          <div className=\"timeline__track timeline__waveform\">\n            <span className=\"timeline__track-label\">Audio</span>\n          </div>\n\n          {/* Arabic captions track */}\n          <div className=\"timeline__track\">\n            <span className=\"timeline__track-label\">Arabic</span>\n            {captions.map((cap) => (\n              <CaptionBlock\n                key={`ar-${cap.id}`}\n                cap={cap}\n                pxPerSec={pxPerSec}\n                totalDuration={totalDuration}\n                variant=\"arabic\"\n                onDragStart={onDragStart}\n                onDragEnd={onDragEnd}\n              />\n            ))}\n          </div>\n\n          {/* Bengali captions track */}\n          <div className=\"timeline__track\">\n            <span className=\"timeline__track-label\">Bengali</span>\n            {captions.map((cap) => (\n              <CaptionBlock\n                key={`bn-${cap.id}`}\n                cap={cap}\n                pxPerSec={pxPerSec}\n                totalDuration={totalDuration}\n                variant=\"bengali\"\n                onDragStart={onDragStart}\n                onDragEnd={onDragEnd}\n              />\n            ))}\n          </div>\n\n          {/* Playhead */}\n          <div className=\"timeline__playhead\" style={{ left: playheadX }} />\n        </div>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\Toolbar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\Versions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\VideoPreview.tsx","messages":[{"ruleId":"react-hooks/set-state-in-effect","severity":2,"message":"Error: Calling setState synchronously within an effect can trigger cascading renders\n\nEffects are intended to synchronize state between React and external systems such as manually updating the DOM, state management libraries, or other platform APIs. In general, the body of an effect should do one or both of the following:\n* Update external systems with the latest state from React.\n* Subscribe for updates from some external system, calling setState in a callback function when external state changes.\n\nCalling setState synchronously within an effect body causes cascading renders that can hurt performance, and is not recommended. (https://react.dev/learn/you-might-not-need-an-effect).\n\nC:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\VideoPreview.tsx:120:5\n  118 |   // Using an effect here is the correct way to respond to external 'metadata' changes from the store.\n  119 |   useEffect((): void => {\n> 120 |     setBannerVisible(false)\n      |     ^^^^^^^^^^^^^^^^ Avoid calling setState() directly within an effect\n  121 |   }, [metadata?.surah])\n  122 |\n  123 |   useEffect((): (() => void) => {","line":120,"column":5,"nodeType":null,"endLine":120,"endColumn":21},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `¬∑`","line":140,"column":34,"nodeType":null,"messageId":"delete","endLine":140,"endColumn":35,"fix":{"range":[5327,5328],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `¬∑`","line":142,"column":46,"nodeType":null,"messageId":"delete","endLine":142,"endColumn":47,"fix":{"range":[5419,5420],"text":""}},{"ruleId":"prettier/prettier","severity":1,"message":"Delete `¬∑`","line":213,"column":38,"nodeType":null,"messageId":"delete","endLine":213,"endColumn":39,"fix":{"range":[7605,7606],"text":""}}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":3,"source":"import { useRef, useEffect, useMemo, useCallback, useState } from 'react'\nimport { useEditorStore } from '../stores/editorStore'\nimport { computeCaptionLayout, formatTimestamp } from '../utils/captionLayout'\nimport { WatermarkOverlay } from './WatermarkOverlay'\n\n/**\n * VideoPreview - native HTML5 <video> + <audio>\n *\n * - audioPath present -> <audio> is master clock, <video> loops silently\n * - only videoPath    -> <video> is master clock\n */\nexport function VideoPreview(): React.ReactElement {\n  const videoRef = useRef<HTMLVideoElement>(null)\n  const audioRef = useRef<HTMLAudioElement>(null)\n  const canvasRef = useRef<HTMLCanvasElement>(null)\n  const containerRef = useRef<HTMLDivElement>(null)\n  const rafRef = useRef<number>(0)\n\n  const videoPath = useEditorStore((s) => s.videoPath)\n  const audioPath = useEditorStore((s) => s.audioPath)\n  const currentTime = useEditorStore((s) => s.currentTime)\n  const setCurrentTime = useEditorStore((s) => s.setCurrentTime)\n  const isPlaying = useEditorStore((s) => s.isPlaying)\n  const setIsPlaying = useEditorStore((s) => s.setIsPlaying)\n  const captions = useEditorStore((s) => s.captions)\n  const captionStyle = useEditorStore((s) => s.captionStyle)\n  const videoDuration = useEditorStore((s) => s.videoDuration)\n  const audioDuration = useEditorStore((s) => s.audioDuration)\n  const setVideoDuration = useEditorStore((s) => s.setVideoDuration)\n  const videoWidth = useEditorStore((s) => s.videoWidth)\n  const videoHeight = useEditorStore((s) => s.videoHeight)\n  const setVideoResolution = useEditorStore((s) => s.setVideoResolution)\n  const metadata = useEditorStore((s) => s.metadata)\n  const renderSettings = useEditorStore((s) => s.renderSettings)\n\n  const [containerSize, setContainerSize] = useState({ width: 800, height: 450 })\n  const [bannerVisible, setBannerVisible] = useState(false)\n  const [volume, setVolume] = useState(0.7)\n  const [isMuted, setIsMuted] = useState(false)\n  const [fontsReady, setFontsReady] = useState(false)\n\n  const masterDuration = audioPath && audioDuration > 0 ? audioDuration : videoDuration\n  // If we have separate audio, the video is treated as background and should always loop\n  const shouldLoopBackground = !!audioPath\n\n  const previewSize = useMemo(() => {\n    const aspect = videoWidth / (videoHeight || 1)\n    const maxW = containerSize.width - 32\n    const maxH = containerSize.height - 32\n    let w = maxW\n    let h = w / aspect\n    if (h > maxH) {\n      h = maxH\n      w = h * aspect\n    }\n    return { width: Math.round(w), height: Math.round(h) }\n  }, [videoWidth, videoHeight, containerSize])\n\n  const previewVideoFilter = useMemo((): string => {\n    switch (renderSettings.videoFilter) {\n      case 'cinematic':\n        return 'contrast(1.18) saturate(0.82) brightness(0.97)'\n      case 'bw':\n        return 'grayscale(1) contrast(1.08) brightness(1.02)'\n      case 'warm':\n        return 'sepia(0.15) saturate(1.1) hue-rotate(-8deg)'\n      case 'cool':\n        return 'saturate(1.05) hue-rotate(10deg) brightness(0.95)'\n      default:\n        return 'none'\n    }\n  }, [renderSettings.videoFilter])\n\n  useEffect((): (() => void) | void => {\n    const el = containerRef.current\n    if (!el) return\n    const observer = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        setContainerSize({\n          width: entry.contentRect.width,\n          height: entry.contentRect.height\n        })\n      }\n    })\n    observer.observe(el)\n    return () => observer.disconnect()\n  }, [])\n\n  // Wait for Google Fonts (Amiri, Noto Sans Bengali) to finish loading\n  // so the canvas can properly shape Arabic/Bengali text.\n  useEffect((): void => {\n    document.fonts.ready.then(() => setFontsReady(true))\n  }, [])\n\n  useEffect((): (() => void) | void => {\n    const video = videoRef.current\n    if (!video || !videoPath) return\n\n    const onMeta = (): void => {\n      setVideoDuration(video.duration || 0)\n      setVideoResolution(video.videoWidth || 1920, video.videoHeight || 1080)\n    }\n    video.addEventListener('loadedmetadata', onMeta)\n    return () => video.removeEventListener('loadedmetadata', onMeta)\n  }, [videoPath, setVideoDuration, setVideoResolution])\n\n  useEffect((): void | (() => void) => {\n    if (metadata?.surah) {\n      const timer = setTimeout(() => setBannerVisible(true), 100)\n      return () => {\n        clearTimeout(timer)\n      }\n    }\n    return undefined\n  }, [metadata?.surah])\n\n  // Reset banner visibility when surah changes. Note: We use metadata?.surah to only trigger on surah ID change.\n  // Using an effect here is the correct way to respond to external 'metadata' changes from the store.\n  useEffect((): void => {\n    setBannerVisible(false)\n  }, [metadata?.surah])\n\n  useEffect((): (() => void) => {\n    const tick = (): void => {\n      const master = audioPath ? audioRef.current : videoRef.current\n      if (master && !master.paused) {\n        setCurrentTime(master.currentTime)\n      }\n      rafRef.current = requestAnimationFrame(tick)\n    }\n    rafRef.current = requestAnimationFrame(tick)\n    return () => cancelAnimationFrame(rafRef.current)\n  }, [audioPath, videoPath, setCurrentTime])\n\n  useEffect((): void => {\n    const master = audioPath ? audioRef.current : videoRef.current\n    if (!master) return\n\n    if (isPlaying) {\n      master.play().catch(() => { })\n      if (audioPath && videoRef.current) {\n        videoRef.current.play().catch(() => { })\n      }\n    } else {\n      master.pause()\n      if (audioPath && videoRef.current) {\n        videoRef.current.pause()\n      }\n    }\n  }, [isPlaying, audioPath, videoPath])\n\n  useEffect((): void => {\n    const effectiveVolume = isMuted ? 0 : volume\n    if (audioRef.current) audioRef.current.volume = effectiveVolume\n    if (videoRef.current) videoRef.current.volume = effectiveVolume\n  }, [volume, isMuted])\n\n  useEffect((): (() => void) | void => {\n    const master = audioPath ? audioRef.current : videoRef.current\n    if (!master) return\n\n    const handleEnded = (): void => {\n      setIsPlaying(false)\n      const endTime = masterDuration > 0 ? masterDuration : master.currentTime\n      setCurrentTime(endTime)\n      if (videoRef.current && audioPath) {\n        videoRef.current.pause()\n      }\n    }\n\n    master.addEventListener('ended', handleEnded)\n    return () => {\n      master.removeEventListener('ended', handleEnded)\n    }\n  }, [audioPath, masterDuration, setCurrentTime, setIsPlaying, videoPath])\n\n  useEffect((): void => {\n    const master = audioPath ? audioRef.current : videoRef.current\n    if (!master) return\n    if (Math.abs(master.currentTime - currentTime) > 0.3) {\n      master.currentTime = currentTime\n    }\n  }, [currentTime, audioPath, videoPath])\n\n  const wrapText = useCallback(\n    (ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string[] => {\n      if (!text) return []\n      const measured = ctx.measureText(text)\n      if (measured.width <= maxWidth) return [text]\n\n      const words = text.split(/\\s+/)\n      const lines: string[] = []\n      let currentLine = ''\n\n      for (const word of words) {\n        const testLine = currentLine ? `${currentLine} ${word}` : word\n        const testWidth = ctx.measureText(testLine).width\n        if (testWidth > maxWidth && currentLine) {\n          lines.push(currentLine)\n          currentLine = word\n        } else {\n          currentLine = testLine\n        }\n      }\n      if (currentLine) lines.push(currentLine)\n      return lines.length > 0 ? lines : [text]\n    },\n    []\n  )\n\n  useEffect((): (() => void) => {\n    const canvas = canvasRef.current\n    if (!canvas) return (): void => { }\n\n    let animId = 0\n    const drawCaptions = (): void => {\n      const ctx = canvas.getContext('2d')\n      if (!ctx) {\n        animId = requestAnimationFrame(drawCaptions)\n        return\n      }\n\n      if (canvas.width !== previewSize.width || canvas.height !== previewSize.height) {\n        canvas.width = previewSize.width\n        canvas.height = previewSize.height\n      }\n\n      ctx.clearRect(0, 0, canvas.width, canvas.height)\n\n      const master = audioPath ? audioRef.current : videoRef.current\n      const time = master ? master.currentTime : currentTime\n      const active = captions.filter((c) => time >= c.start && time <= c.end)\n      if (active.length === 0) {\n        animId = requestAnimationFrame(drawCaptions)\n        return\n      }\n\n      const maxTextWidth = previewSize.width * 0.95\n      const scale = previewSize.height / 1080\n      const animName = captionStyle.animation || 'none'\n\n      // Smooth ease-out cubic function for natural motion\n      const easeOut = (x: number): number => 1 - Math.pow(1 - x, 3)\n\n      for (const cap of active) {\n        const elapsed = Math.max(0, time - cap.start)\n        const baseDur =\n          animName === 'cinematic'\n            ? 1.8\n            : animName === 'typewriter' || animName === 'pop-in'\n              ? 0.3\n              : 0.7\n        const tRaw = Math.min(elapsed / Math.max(baseDur, 0.001), 1)\n        const t = easeOut(tRaw) // Apply easing for smooth motion\n\n        let alpha = 1\n        let xOffset = 0\n        let yOffset = 0\n        let sizeMul = 1\n\n        if (animName !== 'none') {\n          alpha = tRaw // Keep linear alpha for smooth fade\n          switch (animName) {\n            case 'slide-up':\n              yOffset = (1 - t) * 60 * scale\n              break\n            case 'slide-down':\n              yOffset = -(1 - t) * 60 * scale\n              break\n            case 'slide-left':\n              xOffset = (1 - t) * 120 * scale\n              break\n            case 'slide-right':\n              xOffset = -(1 - t) * 120 * scale\n              break\n            case 'pop-in':\n              sizeMul = 0.3 + 0.7 * t\n              yOffset = (1 - t) * 15 * scale\n              break\n            case 'bounce-up':\n              yOffset = (1 - t) * 50 * scale * Math.abs(Math.cos(elapsed * 10))\n              break\n            case 'bounce-down':\n              yOffset = -(1 - t) * 50 * scale * Math.abs(Math.cos(elapsed * 10))\n              break\n            case 'elastic-left':\n              xOffset = (1 - t) * 80 * scale * Math.cos(elapsed * 14)\n              break\n            case 'elastic-right':\n              xOffset = -(1 - t) * 80 * scale * Math.cos(elapsed * 14)\n              break\n            case 'zoom-in':\n              sizeMul = 0.4 + 0.6 * t\n              break\n            case 'zoom-out':\n              sizeMul = 1.6 - 0.6 * t\n              break\n          }\n        }\n\n        const arabicFontSize = Math.max(8, Math.round(captionStyle.arabicSize * scale * sizeMul))\n        const bengaliFontSize = Math.max(8, Math.round(captionStyle.bengaliSize * scale * sizeMul))\n\n        ctx.font = `700 ${arabicFontSize}px \"${captionStyle.arabicFont}\", serif`\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'top'\n        ctx.direction = 'rtl'\n\n        const wrappedArabic: string[] = []\n        for (const line of cap.arabicLines) {\n          wrappedArabic.push(...wrapText(ctx, line, maxTextWidth))\n        }\n\n        ctx.font = `600 ${bengaliFontSize}px \"${captionStyle.bengaliFont}\", sans-serif`\n        const wrappedBengali: string[] = []\n        for (const line of cap.bengaliLines) {\n          wrappedBengali.push(...wrapText(ctx, line, maxTextWidth))\n        }\n\n        const layout = computeCaptionLayout(\n          previewSize.height,\n          captionStyle.positionY,\n          arabicFontSize,\n          wrappedArabic.length,\n          bengaliFontSize,\n          wrappedBengali.length,\n          captionStyle.gap * scale\n        )\n\n        ctx.globalAlpha = alpha\n\n        ctx.font = `700 ${arabicFontSize}px \"${captionStyle.arabicFont}\", serif`\n        ctx.direction = 'rtl'\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'top'\n\n        for (let i = 0; i < wrappedArabic.length; i++) {\n          const y = layout.arabicY + yOffset + i * (arabicFontSize + 12)\n          const x = previewSize.width / 2 + xOffset\n\n          if (captionStyle.strokeWidth > 0) {\n            ctx.strokeStyle = captionStyle.strokeColor\n            ctx.lineWidth = captionStyle.strokeWidth * scale\n            ctx.lineJoin = 'round'\n            ctx.strokeText(wrappedArabic[i], x, y)\n          }\n          ctx.shadowColor = captionStyle.shadowColor\n          ctx.shadowBlur = captionStyle.shadowBlur * scale\n          ctx.fillStyle = captionStyle.arabicColor\n          ctx.fillText(wrappedArabic[i], x, y)\n          ctx.shadowBlur = 0\n        }\n\n        ctx.font = `600 ${bengaliFontSize}px \"${captionStyle.bengaliFont}\", sans-serif`\n        ctx.direction = 'ltr'\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'top'\n\n        for (let i = 0; i < wrappedBengali.length; i++) {\n          const y = layout.bengaliY + yOffset + i * (bengaliFontSize + 12)\n          const x = previewSize.width / 2 + xOffset\n\n          if (captionStyle.strokeWidth > 0) {\n            ctx.strokeStyle = captionStyle.strokeColor\n            ctx.lineWidth = captionStyle.strokeWidth * scale\n            ctx.lineJoin = 'round'\n            ctx.strokeText(wrappedBengali[i], x, y)\n          }\n          ctx.shadowColor = captionStyle.shadowColor\n          ctx.shadowBlur = captionStyle.shadowBlur * scale\n          ctx.fillStyle = captionStyle.bengaliColor\n          ctx.fillText(wrappedBengali[i], x, y)\n          ctx.shadowBlur = 0\n        }\n      }\n\n      ctx.globalAlpha = 1\n      animId = requestAnimationFrame(drawCaptions)\n    }\n\n    animId = requestAnimationFrame(drawCaptions)\n    return () => cancelAnimationFrame(animId)\n  }, [captions, captionStyle, previewSize, audioPath, wrapText, fontsReady, currentTime, videoPath])\n\n  const togglePlay = useCallback((): void => {\n    setIsPlaying(!isPlaying)\n  }, [isPlaying, setIsPlaying])\n\n  const handleSeek = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>): void => {\n      const time = parseFloat(e.target.value)\n      setCurrentTime(time)\n      const master = audioPath ? audioRef.current : videoRef.current\n      if (master) master.currentTime = time\n    },\n    [audioPath, setCurrentTime]\n  )\n\n  const handleVolumeChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>): void => {\n      const next = Math.max(0, Math.min(1, parseFloat(e.target.value)))\n      setVolume(next)\n      if (next > 0 && isMuted) setIsMuted(false)\n    },\n    [isMuted]\n  )\n\n  const toggleMute = useCallback((): void => {\n    setIsMuted((prev) => !prev)\n  }, [])\n\n  if (!videoPath) {\n    return (\n      <div className=\"preview\" ref={containerRef}>\n        <div className=\"preview__empty\">\n          <div className=\"preview__empty-icon\">üé¨</div>\n          <div>Import a video to get started</div>\n        </div>\n      </div>\n    )\n  }\n\n  return (\n    <div className=\"preview\" ref={containerRef}>\n      {audioPath && (\n        <audio\n          ref={audioRef}\n          src={`file://${audioPath}`}\n          preload=\"auto\"\n          style={{ display: 'none' }}\n        />\n      )}\n\n      <div\n        className=\"preview__container\"\n        style={{ width: previewSize.width, height: previewSize.height }}\n      >\n        <video\n          ref={videoRef}\n          className=\"preview__video\"\n          src={`file://${videoPath}`}\n          muted={!!audioPath || isMuted}\n          loop={shouldLoopBackground}\n          playsInline\n          preload=\"auto\"\n          style={{\n            width: '100%',\n            height: '100%',\n            objectFit: 'contain',\n            filter: previewVideoFilter\n          }}\n        />\n\n        {metadata?.surah && (\n          <div\n            className={`preview__surah-banner ${bannerVisible ? 'preview__surah-banner--visible' : ''}`}\n          >\n            <span className=\"preview__surah-icon\">Ô∑Ω</span>\n            <div className=\"preview__surah-info\">\n              <span className=\"preview__surah-name\">{metadata.surah}</span>\n              {metadata.verses && (\n                <span className=\"preview__surah-verses\">Ayah {metadata.verses}</span>\n              )}\n            </div>\n          </div>\n        )}\n\n        <WatermarkOverlay previewWidth={previewSize.width} />\n        <canvas\n          ref={canvasRef}\n          className=\"preview__caption-overlay\"\n          width={previewSize.width}\n          height={previewSize.height}\n        />\n        <div className=\"preview__controls\">\n          <button className=\"btn btn--ghost btn--icon\" onClick={togglePlay}>\n            {isPlaying ? '‚è∏' : '‚ñ∂'}\n          </button>\n          <span className=\"preview__time\">\n            {formatTimestamp(currentTime)} / {formatTimestamp(masterDuration)}\n          </span>\n          <input\n            type=\"range\"\n            className=\"preview__seek\"\n            min={0}\n            max={masterDuration || 1}\n            step={0.01}\n            value={currentTime}\n            onChange={handleSeek}\n          />\n          <div className=\"preview__volume-wrap\">\n            <button\n              className=\"btn btn--ghost btn--icon preview__volume-icon\"\n              onClick={toggleMute}\n              title={isMuted || volume === 0 ? 'Unmute' : 'Mute'}\n            >\n              {isMuted || volume === 0 ? 'üîá' : volume < 0.5 ? 'üîâ' : 'üîä'}\n            </button>\n            <input\n              type=\"range\"\n              className=\"preview__volume\"\n              min={0}\n              max={1}\n              step={0.01}\n              value={isMuted ? 0 : volume}\n              onChange={handleVolumeChange}\n              title={`Volume ${Math.round((isMuted ? 0 : volume) * 100)}%`}\n            />\n          </div>\n        </div>\n      </div>\n    </div>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\components\\WatermarkOverlay.tsx","messages":[{"ruleId":"@typescript-eslint/explicit-function-return-type","severity":2,"message":"Missing return type on function.","line":8,"column":8,"nodeType":"FunctionDeclaration","messageId":"missingReturnType","endLine":8,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Rnd } from 'react-rnd'\nimport { useEditorStore } from '../stores/editorStore'\n\ninterface WatermarkOverlayProps {\n  previewWidth: number\n}\n\nexport function WatermarkOverlay({ previewWidth }: WatermarkOverlayProps) {\n  const watermark = useEditorStore((s) => s.watermark)\n  const setWatermark = useEditorStore((s) => s.setWatermark)\n  const videoWidth = useEditorStore((s) => s.videoWidth)\n\n  if (!watermark) return null\n\n  const scale = previewWidth / videoWidth\n\n  return (\n    <Rnd\n      size={{\n        width: watermark.width * scale,\n        height: watermark.height * scale\n      }}\n      position={{\n        x: watermark.x * scale,\n        y: watermark.y * scale\n      }}\n      onDragStop={(_e, d) => {\n        setWatermark({\n          ...watermark,\n          x: Math.round(d.x / scale),\n          y: Math.round(d.y / scale)\n        })\n      }}\n      onResizeStop={(_e, _dir, ref, _delta, pos) => {\n        setWatermark({\n          ...watermark,\n          width: Math.round(parseInt(ref.style.width) / scale),\n          height: Math.round(parseInt(ref.style.height) / scale),\n          x: Math.round(pos.x / scale),\n          y: Math.round(pos.y / scale)\n        })\n      }}\n      bounds=\"parent\"\n      style={{\n        border: '1px dashed rgba(88, 166, 255, 0.5)',\n        borderRadius: 4,\n        zIndex: 5\n      }}\n    >\n      <img\n        src={`file://${watermark.path}`}\n        alt=\"Watermark\"\n        style={{\n          width: '100%',\n          height: '100%',\n          objectFit: 'contain',\n          opacity: watermark.opacity,\n          pointerEvents: 'none'\n        }}\n      />\n    </Rnd>\n  )\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\hooks\\useVideoSync.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":23,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[927,930],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[927,930],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":39,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1282,1285],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1282,1285],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useRef, useEffect, useCallback } from 'react'\nimport { useEditorStore } from '../stores/editorStore'\n\n/**\n * Hook for frame-accurate caption sync using requestVideoFrameCallback.\n * Falls back to requestAnimationFrame for browsers without RVFC support.\n */\nexport function useVideoSync(mediaRef: React.RefObject<HTMLMediaElement | null>): {\n  startSync: () => void\n  stopSync: () => void\n} {\n  const setCurrentTime = useEditorStore((s) => s.setCurrentTime)\n  const rafId = useRef<number>(0)\n  const cbRef = useRef<((now: number, metadata: { mediaTime: number }) => void) | null>(null)\n\n  const onFrame = useCallback(\n    (now: number, metadata: { mediaTime: number }) => {\n      void now\n      setCurrentTime(metadata.mediaTime)\n      const media = mediaRef.current\n      if (media && 'requestVideoFrameCallback' in media) {\n        // Use cbRef to avoid recursion error during variable declaration\n        ;(media as any).requestVideoFrameCallback(cbRef.current!)\n      }\n    },\n    [setCurrentTime, mediaRef]\n  )\n\n  // Initialize cbRef\n  useEffect(() => {\n    cbRef.current = onFrame\n  }, [onFrame])\n\n  const startSync = useCallback((): void => {\n    const media = mediaRef.current\n    if (!media) return\n\n    if ('requestVideoFrameCallback' in media) {\n      ;(media as any).requestVideoFrameCallback(onFrame)\n    } else {\n      const tick = (): void => {\n        if (media && !media.paused) {\n          setCurrentTime(media.currentTime)\n        }\n        rafId.current = requestAnimationFrame(tick)\n      }\n      rafId.current = requestAnimationFrame(tick)\n    }\n  }, [mediaRef, onFrame, setCurrentTime])\n\n  const stopSync = useCallback((): void => {\n    if (rafId.current) {\n      cancelAnimationFrame(rafId.current)\n      rafId.current = 0\n    }\n  }, [])\n\n  useEffect(() => {\n    return () => stopSync()\n  }, [stopSync])\n\n  return { startSync, stopSync }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\stores\\editorStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\utils\\browserRender.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\utils\\captionLayout.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\utils\\prepareRenderCaptions.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\utils\\testData.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\hacki\\.gemini\\antigravity\\scratch\\quran-video-editor\\src\\renderer\\src\\utils\\textWrapping.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]